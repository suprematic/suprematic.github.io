<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>otplike.supervisor documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Otplike</span> <span class="project-version">0.5.0-alpha-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>otplike</span></div></div></li><li class="depth-2 branch"><a href="otplike.gen-server.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>gen-server</span></div></a></li><li class="depth-2 branch"><a href="otplike.proc-util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proc-util</span></div></a></li><li class="depth-2 branch"><a href="otplike.process.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>process</span></div></a></li><li class="depth-2 branch current"><a href="otplike.supervisor.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>supervisor</span></div></a></li><li class="depth-2 branch"><a href="otplike.timer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>timer</span></div></a></li><li class="depth-2"><a href="otplike.trace.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>trace</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="otplike.supervisor.html#var-check-child-specs"><div class="inner"><span>check-child-specs</span></div></a></li><li class="depth-1"><a href="otplike.supervisor.html#var-delete-child"><div class="inner"><span>delete-child</span></div></a></li><li class="depth-1"><a href="otplike.supervisor.html#var-delete-child.21"><div class="inner"><span>delete-child!</span></div></a></li><li class="depth-1"><a href="otplike.supervisor.html#var-restart-child"><div class="inner"><span>restart-child</span></div></a></li><li class="depth-1"><a href="otplike.supervisor.html#var-restart-child.21"><div class="inner"><span>restart-child!</span></div></a></li><li class="depth-1"><a href="otplike.supervisor.html#var-start-child"><div class="inner"><span>start-child</span></div></a></li><li class="depth-1"><a href="otplike.supervisor.html#var-start-child.21"><div class="inner"><span>start-child!</span></div></a></li><li class="depth-1"><a href="otplike.supervisor.html#var-start-link"><div class="inner"><span>start-link</span></div></a></li><li class="depth-1"><a href="otplike.supervisor.html#var-start-link.21"><div class="inner"><span>start-link!</span></div></a></li><li class="depth-1"><a href="otplike.supervisor.html#var-terminate-child"><div class="inner"><span>terminate-child</span></div></a></li><li class="depth-1"><a href="otplike.supervisor.html#var-terminate-child.21"><div class="inner"><span>terminate-child!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">otplike.supervisor</h1><div class="doc"><div class="markdown"><p>Provides a supervisor, a process that supervises other processes called child processes.</p>
<p>A child process can either be another supervisor or a worker process. Worker processes are normally implemented using <code>gen_server</code> behavior. Supervisors are used to build a hierarchical process structure called a supervision tree, a nice way to structure a fault-tolerant application. For more information, see <a href="https://erldocs.com/current/doc/design_principles/sup_princ.html">Supervisor Behaviour</a> in OTP Design Principles.</p>
<p>A supervisor expects the definition of which child processes to supervise to be specified in the return value of a supervisor’s function.</p>
<p>Unless otherwise stated, all functions of this namespaces fail if the specified supervisor does not exist or if bad arguments are specified.</p>
<h3><a href="#supervision-principles" name="supervision-principles"></a>Supervision Principles</h3>
<p>The supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it must keep its child processes alive by restarting them when necessary.</p>
<p>The children of a supervisor are defined as a list of child specifications. When the supervisor is started, the child processes are started in order from left to right according to this list. When the supervisor terminates, it first terminates its child processes in reversed start order, from right to left.</p>
<p>The supervisor properties are defined by the supervisor flags. The spec definition for the supervisor flags is as follows:</p>
<pre><code>(spec/def ::intensity nat-int?)
(spec/def ::period pos-int?)
(spec/def ::strategy
  #{:one-for-all
    :one-for-one
    :rest-for-one})

(spec/def ::sup-flags
(spec/keys
  :opt-un [::strategy
           ::intensity
           ::period]))
</code></pre>
<p>A supervisor can have one of the following restart strategies specified with the strategy key in the above map:</p>
<p><code>:one-for-one</code> - If one child process terminates and is to be restarted, only that child process is affected. This is the default restart strategy.</p>
<p><code>:one-for-all</code> - If one child process terminates and is to be restarted, all other child processes are terminated and then all child processes are restarted.</p>
<p><code>:rest-for-one</code> - If one child process terminates and is to be restarted, the ‘rest’ of the child processes (that is, the child processes after the terminated child process in the start order) are terminated. Then the terminated child process and all child processes after it are restarted.</p>
<p>To prevent a supervisor from getting into an infinite loop of child process terminations and restarts, a maximum restart intensity is defined using two integer values specified with keys <code>:intensity</code> and <code>:period</code> in the above map. Assuming the values <code>max-r</code> for <code>:intensity</code> and <code>max-t</code> for <code>:period</code>, then, if more than <code>max-r</code> restarts occur within <code>max-t</code> seconds, the supervisor terminates all child processes and then itself. The termination reason for the supervisor itself in that case will be <code>:shutdown</code>. intensity defaults to <code>1</code> and period defaults to <code>5</code>.</p>
<p>The spec definition of a child specification is as follows:</p>
<pre><code>(spec/def ::timeout (spec/or :ms nat-int? :inf #{:infinity}))
(spec/def ::args (spec/coll-of any?))

(spec/def ::id any?)
(spec/def ::start (spec/tuple fn? ::args))
(spec/def ::restart #{:permanent :transient :temporary})
(spec/def ::shutdown
(spec/or :brutal-kill #{:brutal-kill}
         :timeout ::timeout))
(spec/def ::type #{:worker :supervisor})

(spec/def ::child-spec
(spec/keys
  :req-un [::id
           ::start]
  :opt-un [::restart
           ::shutdown
           ::type]))
</code></pre>
<p><code>:id</code> is used to identify the child specification internally by the supervisor.</p>
<p><code>:start</code> defines the function call used to start the child process. It must be a function-arguments tuple <code>[f args]</code> used as <code>(apply f args)</code>.</p>
<p>The start function must create a child process and link to it, and must return <code>[:ok child-pid]</code> or <code>[:ok child-pid info]</code>, where <code>info</code> is any value that is ignored by the supervisor. The function is allowed to return async value wrapping the actual return.</p>
<p>If something goes wrong, the function can also return an error tuple <code>[:error error]</code>.</p>
<p>Notice that the <code>gen-server/start-link</code> functions fulfill the above requirements.</p>
<p><code>:restart</code> defines when a terminated child process must be restarted. A <code>:permanent</code> child process is always restarted. A <code>:temporary</code> child process is never restarted (even when the supervisor’s restart strategy is <code>:rest-for-one</code> or <code>one-for-all</code> and a sibling’s death causes the temporary process to be terminated). A <code>:transient</code> child process is restarted only if it terminates abnormally, that is, with another exit reason than <code>:normal</code>, <code>:shutdown</code>, or <code>[:shutdown reason]</code>. The <code>:restart</code> key is optional and defaults to <code>:permanent</code>.</p>
<p><code>:shutdown</code> defines how a child process must be terminated. <code>:brutal-kill</code> means that the child process is unconditionally terminated using <code>(process/exit child-pid :kill)</code>. An integer time-out value means that the supervisor tells the child process to terminate by calling <code>(process/exit child-pid :shutdown)</code> and then wait for an exit signal with reason <code>:shutdown</code> back from the child process. If no exit signal is received within the specified number of milliseconds, the child process is unconditionally terminated using <code>(process/exit child-id :kill)</code>.</p>
<p>If the child process is another supervisor, the shutdown time is to be set to <code>:infinity</code> to give the subtree ample time to shut down. It is also allowed to set it to <code>:infinity</code>, if the child process is a worker.</p>
<blockquote>
  <p><strong>Warning!</strong> Be careful when setting the shutdown time to <code>:infinity</code> when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return.</p>
</blockquote>
<p>Notice that all child processes implemented using the standard behaviors (<code>gen-server</code>) automatically adhere to the shutdown protocol.</p>
<p>The <code>:shutdown</code> key is optional. If it is not specified, it defaults to <code>5000</code> if the child is of type <code>:worker</code> and it defaults to <code>:infinity</code> if the child is of type <code>:supervisor</code>.</p>
<p><code>:type</code> specifies if the child process is a supervisor or a worker. The <code>:type</code> key is optional and defaults to <code>:worker</code>.</p></div></div><div class="public anchor" id="var-check-child-specs"><h3>check-child-specs</h3><div class="usage"><code>(check-child-specs spec)</code></div><div class="doc"><div class="markdown"><p>Takes a list of child specification and returns <code>:ok</code> if all of them are syntactically correct, otherwise <code>[error, reason]</code>.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L937">view source</a></div></div><div class="public anchor" id="var-delete-child"><h3>delete-child</h3><div class="usage"><code>(delete-child sup id)</code></div><div class="doc"><div class="markdown"><p>The same as <code>delete-child!</code> but returns async value.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L1082">view source</a></div></div><div class="public anchor" id="var-delete-child.21"><h3>delete-child!</h3><h4 class="type">macro</h4><div class="usage"><code>(delete-child! sup id)</code></div><div class="doc"><div class="markdown"><p>Tells supervisor to delete the child specification identified by <code>id</code>. The corresponding child process must not be running. Use <code>terminate-child</code> to terminate it.</p>
<p>If successful, the function returns <code>:ok</code>. If the child specification identified by <code>id</code> exists but the corresponding child process is running or is about to be restarted, the function returns <code>[:error :running]</code> or <code>[:error :restarting]</code>, respectively. If the child specification identified by <code>id</code> does not exist, the function returns <code>[:error :not-found]</code>.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L1065">view source</a></div></div><div class="public anchor" id="var-restart-child"><h3>restart-child</h3><div class="usage"><code>(restart-child sup id)</code></div><div class="doc"><div class="markdown"><p>The same as <code>restart-child!</code> but returns async value.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L1023">view source</a></div></div><div class="public anchor" id="var-restart-child.21"><h3>restart-child!</h3><h4 class="type">macro</h4><div class="usage"><code>(restart-child! sup id)</code></div><div class="doc"><div class="markdown"><p>Tells supervisor to restart a child process corresponding to the child specification identified by <code>id</code>. The child specification must exist, and the corresponding child process must not be running.</p>
<p>Notice that for temporary children, the child specification is automatically deleted when the child terminates; thus, it is not possible to restart such children.</p>
<p>If the child specification identified by <code>id</code> does not exist, the function returns <code>[:error :not-found]</code>. If the child specification exists but the corresponding process is already running, the function returns <code>[:error :running]</code>.</p>
<p>If the child process start function returns <code>[:ok pid]</code>, the <code>pid</code> is added to the supervisor and the function returns the same value.</p>
<p>If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns <code>[:error error]</code>, where <code>error</code> is a form containing information about the error.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L995">view source</a></div></div><div class="public anchor" id="var-start-child"><h3>start-child</h3><div class="usage"><code>(start-child sup child-spec)</code></div><div class="doc"><div class="markdown"><p>The same as <code>start-child!</code> but returns async value.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L985">view source</a></div></div><div class="public anchor" id="var-start-child.21"><h3>start-child!</h3><h4 class="type">macro</h4><div class="usage"><code>(start-child! sup child-spec)</code></div><div class="doc"><div class="markdown"><p>Dynamically adds a child specification to supervisor <code>sup</code>, which starts the corresponding child process.</p>
<p><code>sup</code> can be a pid or a registered name.</p>
<p><code>child-spec</code> must be a valid child specification. The child process is started by using the start function as defined in the child specification.</p>
<p>If there already exists a child specification with the specified identifier, <code>child-spec</code> is discarded, and the function returns <code>[:error :already-present]</code> or <code>[:error [:already-started child]]</code>, depending on if the corresponding child process is running or not.</p>
<p>If the child process start function returns <code>[:ok child-pid]</code>, the child specification and pid are added to the supervisor and the function returns the same value.</p>
<p>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded, and the function returns <code>[:error error]</code>, where <code>error</code> is a form containing information about the error and child specification.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L956">view source</a></div></div><div class="public anchor" id="var-start-link"><h3>start-link</h3><div class="usage"><code>(start-link sup-fn)</code><code>(start-link sup-fn args)</code><code>(start-link sup-name sup-fn args)</code></div><div class="doc"><div class="markdown"><p>The same as <code>start-link!</code> but returns async value.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L924">view source</a></div></div><div class="public anchor" id="var-start-link.21"><h3>start-link!</h3><h4 class="type">macro</h4><div class="usage"><code>(start-link! sup-fn)</code><code>(start-link! sup-fn args)</code><code>(start-link! sup-name sup-fn args)</code></div><div class="doc"><div class="markdown"><p>Creates a supervisor process as part of a supervision tree. For example, the function ensures that the supervisor is linked to the calling process (its supervisor).</p>
<p>The created supervisor process calls <code>sup-fn</code> to find out about restart strategy, maximum restart intensity, and child processes. To ensure a synchronized startup procedure, <code>start-link!</code> does not return until <code>sup-fn</code> has returned and all child processes have been started. <code>sup-fn</code> is allowed to return async value wrapping the actual return.</p>
<p>If <code>sup-name</code> is provided, the supervisor is registered locally as <code>sup-name</code>.</p>
<p><code>args</code> is a vector of the arguments to <code>sup-fn</code>.</p>
<p>If the supervisor and its child processes are successfully created (that is, if all child process start functions return <code>[ok, child-pid]</code>), the function returns <code>[ok, pid]</code>, where <code>pid</code> is the pid of the supervisor.</p>
<p>If there already exists a process with the specified <code>sup-name</code>, the function retunrs <code>[:error reason]</code>.</p>
<p>If <code>sup-fn</code> fails or returns an incorrect value, this function returns <code>[:error ([:bad-return-value 'init ret] :as reason)]</code> , where <code>ret</code> is the returned value, and the supervisor terminates with the same reason.</p>
<p>If any child process start function fails or returns an error tuple or an erroneous value, the supervisor first terminates all already started child processes with reason <code>:shutdown</code> and then terminate itself and returns <code>[:error, [:shutdown reason]]</code>.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L875">view source</a></div></div><div class="public anchor" id="var-terminate-child"><h3>terminate-child</h3><div class="usage"><code>(terminate-child sup id)</code></div><div class="doc"><div class="markdown"><p>The same as <code>terminate-child!</code> but returns async value.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L1055">view source</a></div></div><div class="public anchor" id="var-terminate-child.21"><h3>terminate-child!</h3><h4 class="type">macro</h4><div class="usage"><code>(terminate-child! sup id)</code></div><div class="doc"><div class="markdown"><p>Tells supervisor to terminate the specified child.</p>
<p><code>id</code> must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling <code>restart-child</code>. Use <code>delete-child</code> to remove the child specification.</p>
<p>If the child is temporary, the child specification is deleted as soon as the process terminates. This means that <code>delete-child</code> has no meaning and <code>restart-child</code> cannot be used for these children.</p>
<p>If successful, the function returns <code>:ok</code>. If there is no child specification with the specified <code>id</code>, the function returns <code>[:error :not-found]</code>.</p></div></div><div class="src-link"><a href="https://github.com/suprematic/otplike/blob/0.5.0-alpha-SNAPSHOT/src/otplike/supervisor.clj#L1032">view source</a></div></div></div></body></html>